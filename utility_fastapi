from fastapi import FastAPI, HTTPException, Depends, Header
from fastapi.responses import JSONResponse
from pydantic import BaseModel
import requests
import json
import getpass
import os
import uvicorn
from typing import Optional

app = FastAPI(title="Session Launch API", version="1.0.0")

# Pydantic models for request/response
class LaunchSessionRequest(BaseModel):
    session_name: str = "My JupyterLab Session-1"
    workbench: str = "JupyterLab"
    cluster: str = "Local"

class LaunchSessionResponse(BaseModel):
    success: bool
    message: str
    session_url: Optional[str] = None
    error: Optional[str] = None

class TokenResponse(BaseModel):
    user_id: str
    token: Optional[str] = None
    available_users: list = []

def get_token_from_json(user_id: str, filename: str = "tokens.json") -> Optional[str]:
    """Read token from JSON file based on user ID"""
    try:
        # Get the directory where the script is located
        script_dir = os.path.dirname(os.path.abspath(__file__))
        token_file_path = os.path.join(script_dir, filename)
        
        with open(token_file_path, 'r') as file:
            tokens = json.load(file)
            return tokens.get(user_id)
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail=f"Token file '{filename}' not found")
    except json.JSONDecodeError:
        raise HTTPException(status_code=400, detail=f"Error parsing JSON file '{filename}'")

def get_available_users(filename: str = "tokens.json") -> list:
    """Get list of available users from tokens file"""
    try:
        script_dir = os.path.dirname(os.path.abspath(__file__))
        token_file_path = os.path.join(script_dir, filename)
        
        with open(token_file_path, 'r') as file:
            tokens = json.load(file)
            return list(tokens.keys())
    except (FileNotFoundError, json.JSONDecodeError):
        return []

async def launch_session_api(base_url: str, api_endpoint: str, token: str, 
                            session_name: str = "My JupyterLab Session-1", 
                            workbench: str = "JupyterLab", 
                            cluster: str = "Local") -> dict:
    """
    Launch a session using the provided API
    """
    payload = json.dumps({
        "method": "launch_session",
        "kwparams": {
            "workbench": workbench,
            "name": session_name,
            "launch_parameters": {
                "name": f"{getpass.getuser()}-JL3",
                "cluster": cluster,
                "placement_constraints": [],
                "resource_limits": [],
                "queues": []
            }
        }
    })

    headers = {
        'Content-Type': 'application/json',
        'Authorization': f'Bearer {token}'
    }

    try:
        response = requests.request("POST", base_url + api_endpoint, 
                                  headers=headers, data=payload, verify=False)
        response.raise_for_status()
        
        return json.loads(response.text)
        
    except requests.exceptions.RequestException as e:
        raise HTTPException(status_code=500, detail=f"Request to external API failed: {e}")
    except json.JSONDecodeError as e:
        raise HTTPException(status_code=500, detail=f"Failed to parse response JSON: {e}")

@app.get("/")
async def root():
    """Root endpoint with API information"""
    return {
        "message": "Session Launch API",
        "version": "1.0.0",
        "endpoints": {
            "GET /tokens/{user_id}": "Get token for a specific user",
            "POST /launch-session": "Launch a new session",
            "GET /available-users": "Get list of available users"
        }
    }

@app.get("/tokens/{user_id}", response_model=TokenResponse)
async def get_token(user_id: str):
    """Get token for a specific user"""
    token = get_token_from_json(user_id)
    available_users = get_available_users()
    
    return TokenResponse(
        user_id=user_id,
        token=token,
        available_users=available_users
    )

@app.get("/available-users")
async def get_available_users_endpoint():
    """Get list of available users from tokens file"""
    users = get_available_users()
    return {"available_users": users}

@app.post("/launch-session", response_model=LaunchSessionResponse)
async def launch_session_endpoint(
    request: LaunchSessionRequest,
    authorization: Optional[str] = Header(None),
    x_user_id: Optional[str] = Header(None)
):
    """
    Launch a session with the provided parameters
    
    You can either:
    1. Provide an Authorization header with the token directly
    2. Provide an X-User-ID header to look up the token from tokens.json
    3. If no headers provided, it will use the current system user
    """
    # Configuration
    base_url = "https://url"
    launch_api = "/api/launch_session"
    
    # Determine user and token
    if authorization and authorization.startswith("Bearer "):
        # Use token from Authorization header
        token = authorization.replace("Bearer ", "")
        user_id = "from_header"
    elif x_user_id:
        # Look up token by user ID
        user_id = x_user_id
        token = get_token_from_json(user_id)
        if not token:
            raise HTTPException(status_code=404, detail=f"Token not found for user: {user_id}")
    else:
        # Use current system user
        user_id = getpass.getuser()
        token = get_token_from_json(user_id)
        if not token:
            available_users = get_available_users()
            raise HTTPException(
                status_code=404, 
                detail={
                    "message": f"Token not found for current user: {user_id}",
                    "available_users": available_users
                }
            )

    # Launch the session
    try:
        response_data = await launch_session_api(
            base_url=base_url,
            api_endpoint=launch_api,
            token=token,
            session_name=request.session_name,
            workbench=request.workbench,
            cluster=request.cluster
        )

        if response_data and "result" in response_data and "url" in response_data["result"]:
            full_url = base_url + response_data["result"]["url"]
            return LaunchSessionResponse(
                success=True,
                message="Session launched successfully",
                session_url=full_url
            )
        else:
            return LaunchSessionResponse(
                success=False,
                message="Unexpected response format from external API",
                error=str(response_data)
            )
            
    except HTTPException:
        raise
    except Exception as e:
        return LaunchSessionResponse(
            success=False,
            message="Failed to launch session",
            error=str(e)
        )

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
