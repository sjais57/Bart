from fastapi import FastAPI, HTTPException, Header
from pydantic import BaseModel
import requests
import json
import getpass
import os
import uvicorn
import re
from typing import Optional, List, Dict, Any

app = FastAPI(title="Session Management API", version="1.0.0")

# Pydantic models for request/response
class LaunchSessionRequest(BaseModel):
    session_name: str = "My JupyterLab Session-1"
    workbench: str = "JupyterLab"
    cluster: str = "Local"

class LaunchSessionResponse(BaseModel):
    success: bool
    message: str
    session_url: Optional[str] = None
    error: Optional[str] = None

class SessionInfo(BaseModel):
    session_id: str
    url: str
    session_name: str
    display_name: str

class GetSessionsResponse(BaseModel):
    success: bool
    message: str
    sessions: List[SessionInfo] = []
    error: Optional[str] = None

class TokenResponse(BaseModel):
    user_id: str
    token: Optional[str] = None
    available_users: List[str] = []

class AvailableUsersResponse(BaseModel):
    available_users: List[str]

# Configuration
BASE_URL = "https://url"
LAUNCH_API = "/api/launch_session"
GET_SESSION_API = "/api/get_session"

# Helper functions
def get_token_from_json(user_id: str, filename: str = "tokens.json") -> Optional[str]:
    """Read token from JSON file based on user ID"""
    try:
        script_dir = os.path.dirname(os.path.abspath(__file__))
        token_file_path = os.path.join(script_dir, filename)
        
        with open(token_file_path, 'r') as file:
            tokens = json.load(file)
            return tokens.get(user_id)
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail=f"Token file '{filename}' not found")
    except json.JSONDecodeError:
        raise HTTPException(status_code=400, detail=f"Error parsing JSON file '{filename}'")

def get_available_users(filename: str = "tokens.json") -> List[str]:
    """Get list of available users from tokens file"""
    try:
        script_dir = os.path.dirname(os.path.abspath(__file__))
        token_file_path = os.path.join(script_dir, filename)
        
        with open(token_file_path, 'r') as file:
            tokens = json.load(file)
            return list(tokens.keys())
    except (FileNotFoundError, json.JSONDecodeError):
        return []

def get_user_token(x_user_id: Optional[str] = None) -> tuple[str, str]:
    """Centralized function to get user ID and token"""
    if x_user_id:
        # Look up token by user ID from header
        user_id = x_user_id
        token = get_token_from_json(user_id)
        if not token:
            available_users = get_available_users()
            raise HTTPException(
                status_code=404, 
                detail={
                    "message": f"Token not found for user: {user_id}",
                    "available_users": available_users
                }
            )
    else:
        # Use current system user
        user_id = getpass.getuser()
        token = get_token_from_json(user_id)
        if not token:
            available_users = get_available_users()
            raise HTTPException(
                status_code=404, 
                detail={
                    "message": f"Token not found for current user: {user_id}",
                    "available_users": available_users
                }
            )
    
    return user_id, token

async def make_api_request(api_endpoint: str, payload: dict, token: str) -> Dict[str, Any]:
    """Make API request to external service"""
    headers = {
        'Content-Type': 'application/json',
        'Authorization': f'Bearer {token}'
    }

    try:
        response = requests.request("POST", BASE_URL + api_endpoint, 
                                  headers=headers, data=json.dumps(payload), verify=False)
        response.raise_for_status()
        return json.loads(response.text)
        
    except requests.exceptions.RequestException as e:
        raise HTTPException(status_code=500, detail=f"Request to external API failed: {e}")
    except json.JSONDecodeError as e:
        raise HTTPException(status_code=500, detail=f"Failed to parse response JSON: {e}")

async def get_sessions_api(token: str) -> Dict[str, Any]:
    """Get sessions using the provided API"""
    payload = {
        "method": "get_session"
    }
    
    return await make_api_request(GET_SESSION_API, payload, token)

def extract_session_info(session_data: Dict[str, Any]) -> SessionInfo:
    """Extract session information from the API response"""
    # Try different possible field names for session name
    display_name = session_data.get("display_name", "")
    
    # If display_name is empty, try other possible fields
    if not display_name:
        display_name = session_data.get("name", session_data.get("session_name", ""))
    
    return SessionInfo(
        session_id=session_data.get("id", ""),
        url=BASE_URL + session_data.get("url", ""),
        session_name=display_name,
        display_name=display_name
    )

def get_next_available_session_number(existing_sessions: List[SessionInfo], username: str) -> int:
    """
    Find the next available session number by checking existing session names.
    Pattern: {username}-JL_Session-{number}
    """
    pattern = re.compile(rf"^{re.escape(username)}-JL_Session-(\d+)$")
    used_numbers = set()
    
    for session in existing_sessions:
        # Check the display_name field where the session name is stored
        match = pattern.match(session.display_name)
        if match:
            try:
                used_numbers.add(int(match.group(1)))
            except (ValueError, TypeError):
                # Handle cases where the number is not a valid integer
                continue
    
    # Find the first available number starting from 1
    next_number = 1
    while next_number in used_numbers:
        next_number += 1
    
    return next_number

async def launch_session_api(token: str, session_name: str, workbench: str, cluster: str, username: str) -> dict:
    """Launch a session using the provided API with unique name"""
    # First get existing sessions to determine next available number
    try:
        sessions_response = await get_sessions_api(token)
        existing_sessions = []
        
        if sessions_response and "result" in sessions_response and "sessions" in sessions_response["result"]:
            for session_data in sessions_response["result"]["sessions"]:
                session_info = extract_session_info(session_data)
                existing_sessions.append(session_info)
        
        # Get next available session number
        next_number = get_next_available_session_number(existing_sessions, username)
        unique_session_name = f"{username}-JL_Session-{next_number}"
        
    except Exception as e:
        # If we can't get existing sessions, fall back to original naming
        print(f"Error getting existing sessions, using fallback naming: {e}")
        unique_session_name = f"{username}-JL3"
    
    payload = {
        "method": "launch_session",
        "kwparams": {
            "workbench": workbench,
            "name": session_name,
            "launch_parameters": {
                "name": unique_session_name,
                "cluster": cluster,
                "placement_constraints": [],
                "resource_limits": [],
                "queues": []
            }
        }
    }
    
    return await make_api_request(LAUNCH_API, payload, token)

# Endpoints
@app.get("/")
async def root():
    """Root endpoint with API information"""
    return {
        "message": "Session Management API",
        "version": "1.0.0",
        "endpoints": {
            "GET /tokens": "Get token for a user (optional user_id query param)",
            "POST /launch-session": "Launch a new session",
            "GET /sessions": "Get all sessions for a user",
            "GET /available-users": "Get list of available users"
        }
    }

@app.get("/tokens", response_model=TokenResponse)
async def get_token(user_id: Optional[str] = None):
    """Get token for a specific user. If no user_id provided, returns token for current system user."""
    if user_id is None:
        # Use current system user if no user_id provided
        user_id = getpass.getuser()
    
    token = get_token_from_json(user_id)
    available_users = get_available_users()
    
    return TokenResponse(
        user_id=user_id,
        token=token,
        available_users=available_users
    )

@app.get("/available-users", response_model=AvailableUsersResponse)
async def get_available_users_endpoint():
    """Get list of available users from tokens file"""
    users = get_available_users()
    return AvailableUsersResponse(available_users=users)

@app.post("/launch-session", response_model=LaunchSessionResponse)
async def launch_session_endpoint(
    request: LaunchSessionRequest,
    x_user_id: Optional[str] = Header(None, description="User ID to look up token from tokens.json")
):
    """
    Launch a session with the provided parameters
    
    You can either:
    1. Provide an X-User-ID header to look up the token from tokens.json
    2. If no header provided, it will use the current system user
    """
    # Get user and token (centralized logic)
    user_id, token = get_user_token(x_user_id)

    # Launch the session
    try:
        response_data = await launch_session_api(
            token=token,
            session_name=request.session_name,
            workbench=request.workbench,
            cluster=request.cluster,
            username=user_id
        )

        if response_data and "result" in response_data and "url" in response_data["result"]:
            full_url = BASE_URL + response_data["result"]["url"]
            return LaunchSessionResponse(
                success=True,
                message="Session launched successfully",
                session_url=full_url
            )
        else:
            return LaunchSessionResponse(
                success=False,
                message="Unexpected response format from external API",
                error=str(response_data)
            )
            
    except HTTPException:
        raise
    except Exception as e:
        return LaunchSessionResponse(
            success=False,
            message="Failed to launch session",
            error=str(e)
        )

@app.get("/sessions", response_model=GetSessionsResponse)
async def get_sessions_endpoint(
    x_user_id: Optional[str] = Header(None, description="User ID to look up token from tokens.json")
):
    """
    Get all sessions for a user
    
    You can either:
    1. Provide an X-User-ID header to look up the token from tokens.json
    2. If no header provided, it will use the current system user
    """
    # Get user and token (centralized logic)
    user_id, token = get_user_token(x_user_id)

    # Get sessions
    try:
        response_data = await get_sessions_api(token)

        if response_data and "result" in response_data and "sessions" in response_data["result"]:
            sessions = []
            for session_data in response_data["result"]["sessions"]:
                session_info = extract_session_info(session_data)
                sessions.append(session_info)
            
            return GetSessionsResponse(
                success=True,
                message=f"Found {len(sessions)} sessions",
                sessions=sessions
            )
        else:
            return GetSessionsResponse(
                success=False,
                message="No sessions found or unexpected response format",
                error=str(response_data) if response_data else "Empty response"
            )
            
    except HTTPException:
        raise
    except Exception as e:
        return GetSessionsResponse(
            success=False,
            message="Failed to get sessions",
            error=str(e)
        )

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
