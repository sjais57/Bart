from fastapi import FastAPI, HTTPException, Header
from pydantic import BaseModel, Field
import requests
import json
import getpass
import os
import uvicorn
import re
from typing import List, Dict, Any

app = FastAPI(title="Session Management API", version="1.0.0")

# Pydantic models for request/response
class LaunchSessionRequest(BaseModel):
    session_name: str = "My JupyterLab Session-1"
    workbench: str = "JupyterLab"
    cluster: str = "Local"
    base_url: str = Field(..., description="Base URL for the API (without https://)")

class StopSessionRequest(BaseModel):
    session_ids: List[str]
    force_quit: bool = False
    suspend_session: bool = False
    base_url: str = Field(..., description="Base URL for the API (without https://)")

class LaunchSessionResponse(BaseModel):
    success: bool
    message: str
    session_url: str = None
    error: str = None

class SessionInfo(BaseModel):
    session_id: str
    url: str
    session_name: str
    display_name: str

class GetSessionsResponse(BaseModel):
    success: bool
    message: str
    sessions: List[SessionInfo] = []
    error: str = None

class StopSessionResponse(BaseModel):
    success: bool
    message: str
    stopped_sessions: List[str] = []
    error: str = None

class TokenResponse(BaseModel):
    username: str
    token: str = None
    available_users: List[str] = []

class AvailableUsersResponse(BaseModel):
    available_users: List[str]

# API endpoints (relative paths)
LAUNCH_API = "/api/launch_session"
GET_SESSION_API = "/api/get_session"
STOP_SESSION_API = "/api/stop_session"

def format_base_url(base_url: str) -> str:
    """Format base URL to ensure it has https:// prefix"""
    if not base_url.startswith(('http://', 'https://')):
        return f"https://{base_url}"
    return base_url

# Helper functions
def get_token_from_json(username: str, filename: str = "tokens.json") -> str:
    """Read token from JSON file based on user ID"""
    try:
        script_dir = os.path.dirname(os.path.abspath(__file__))
        token_file_path = os.path.join(script_dir, filename)
        
        with open(token_file_path, 'r') as file:
            tokens = json.load(file)
            token = tokens.get(username)
            if not token:
                raise HTTPException(status_code=404, detail=f"Token not found for user: {username}")
            return token
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail=f"Token file '{filename}' not found")
    except json.JSONDecodeError:
        raise HTTPException(status_code=400, detail=f"Error parsing JSON file '{filename}'")

def get_available_users(filename: str = "tokens.json") -> List[str]:
    """Get list of available users from tokens file"""
    try:
        script_dir = os.path.dirname(os.path.abspath(__file__))
        token_file_path = os.path.join(script_dir, filename)
        
        with open(token_file_path, 'r') as file:
            tokens = json.load(file)
            return list(tokens.keys())
    except (FileNotFoundError, json.JSONDecodeError):
        return []

def get_user_token(username: str) -> tuple[str, str]:
    """Centralized function to get user ID and token - username is mandatory"""
    token = get_token_from_json(username)
    return username, token

async def make_api_request(base_url: str, api_endpoint: str, payload: dict, token: str) -> Dict[str, Any]:
    """Make API request to external service"""
    headers = {
        'Content-Type': 'application/json',
        'Authorization': f'Bearer {token}'
    }

    try:
        formatted_base_url = format_base_url(base_url)
        response = requests.request("POST", formatted_base_url + api_endpoint, 
                                  headers=headers, data=json.dumps(payload), verify=False)
        response.raise_for_status()
        return json.loads(response.text)
        
    except requests.exceptions.RequestException as e:
        raise HTTPException(status_code=500, detail=f"Request to external API failed: {e}")
    except json.JSONDecodeError as e:
        raise HTTPException(status_code=500, detail=f"Failed to parse response JSON: {e}")

async def get_sessions_api(base_url: str, token: str) -> Dict[str, Any]:
    """Get sessions using the provided API"""
    payload = {
        "method": "get_session"
    }
    
    return await make_api_request(base_url, GET_SESSION_API, payload, token)

async def stop_session_api(base_url: str, token: str, session_ids: List[str], force_quit: bool = False, suspend_session: bool = False) -> Dict[str, Any]:
    """Stop/kill sessions using the provided API"""
    # Convert session_ids list to comma-separated string for the external API
    session_ids_str = ",".join(session_ids)
    
    payload = {
        "method": "stop_session",
        "kwparams": {
            "session_ids": session_ids_str,  # Send as string
            "force_quit": force_quit,
            "suspend_session": suspend_session
        }
    }
    
    return await make_api_request(base_url, STOP_SESSION_API, payload, token)

def extract_session_info(base_url: str, session_data: Dict[str, Any]) -> SessionInfo:
    """Extract session information from the API response"""
    display_name = session_data.get("display_name", "")
    
    if not display_name:
        display_name = session_data.get("name", session_data.get("session_name", ""))
    
    formatted_base_url = format_base_url(base_url)
    return SessionInfo(
        session_id=session_data.get("id", ""),
        url=formatted_base_url + session_data.get("url", ""),
        session_name=display_name,
        display_name=display_name
    )

def get_next_available_session_number(existing_sessions: List[SessionInfo], username: str) -> int:
    """
    Find the next available session number by checking existing session names.
    Pattern: {username}-JL_Session-{number}
    """
    pattern = re.compile(rf"^{re.escape(username)}-JL_Session-(\d+)$")
    used_numbers = set()
    
    for session in existing_sessions:
        match = pattern.match(session.display_name)
        if match:
            try:
                used_numbers.add(int(match.group(1)))
            except (ValueError, TypeError):
                continue
    
    next_number = 1
    while next_number in used_numbers:
        next_number += 1
    
    return next_number

async def launch_session_api(base_url: str, token: str, session_name: str, workbench: str, cluster: str, username: str) -> dict:
    """Launch a session using the provided API with unique name"""
    try:
        sessions_response = await get_sessions_api(base_url, token)
        existing_sessions = []
        
        if sessions_response and "result" in sessions_response and "sessions" in sessions_response["result"]:
            for session_data in sessions_response["result"]["sessions"]:
                session_info = extract_session_info(base_url, session_data)
                existing_sessions.append(session_info)
        
        next_number = get_next_available_session_number(existing_sessions, username)
        unique_session_name = f"{username}-JL_Session-{next_number}"
        
    except Exception as e:
        print(f"Error getting existing sessions, using simple naming: {e}")
        unique_session_name = f"{username}-JL_Session-1"
    
    payload = {
        "method": "launch_session",
        "kwparams": {
            "workbench": workbench,
            "name": session_name,
            "launch_parameters": {
                "name": unique_session_name,
                "cluster": cluster,
                "placement_constraints": [],
                "resource_limits": [],
                "queues": []
            }
        }
    }
    
    return await make_api_request(base_url, LAUNCH_API, payload, token)

# Endpoints
@app.get("/")
async def root():
    """Root endpoint with API information"""
    return {
        "message": "Session Management API",
        "version": "1.0.0",
        "endpoints": {
            "GET /tokens/{username}": "Get token for a specific user",
            "POST /launch-session": "Launch a new session (requires X-User-ID header and base_url in body)",
            "GET /sessions": "Get all sessions for a user (requires X-User-ID header and base_url in query)",
            "POST /stop-session": "Stop/kill one or more sessions (requires X-User-ID header and base_url in body)",
            "GET /available-users": "Get list of available users"
        }
    }

@app.get("/tokens/{username}", response_model=TokenResponse)
async def get_token(username: str):
    """Get token for a specific user"""
    token = get_token_from_json(username)
    available_users = get_available_users()
    
    return TokenResponse(
        username=username,
        token=token,
        available_users=available_users
    )

@app.get("/available-users", response_model=AvailableUsersResponse)
async def get_available_users_endpoint():
    """Get list of available users from tokens file"""
    users = get_available_users()
    return AvailableUsersResponse(available_users=users)

@app.post("/launch-session", response_model=LaunchSessionResponse)
async def launch_session_endpoint(
    request: LaunchSessionRequest,
    username: str = Header(..., description="User ID to look up token from tokens.json")
):
    """Launch a session with the provided parameters"""
    username, token = get_user_token(username)

    try:
        response_data = await launch_session_api(
            base_url=request.base_url,
            token=token,
            session_name=request.session_name,
            workbench=request.workbench,
            cluster=request.cluster,
            username=username
        )

        if response_data and "result" in response_data and "url" in response_data["result"]:
            formatted_base_url = format_base_url(request.base_url)
            full_url = formatted_base_url + response_data["result"]["url"]
            return LaunchSessionResponse(
                success=True,
                message="Session launched successfully",
                session_url=full_url
            )
        else:
            return LaunchSessionResponse(
                success=False,
                message="Unexpected response format from external API",
                error=str(response_data)
            )
            
    except HTTPException:
        raise
    except Exception as e:
        return LaunchSessionResponse(
            success=False,
            message="Failed to launch session",
            error=str(e)
        )

@app.get("/sessions", response_model=GetSessionsResponse)
async def get_sessions_endpoint(
    username: str = Header(..., description="User ID to look up token from tokens.json"),
    base_url: str = Header(..., description="Base URL for the API (without https://)")
):
    """Get all sessions for a user"""
    username, token = get_user_token(username)

    try:
        response_data = await get_sessions_api(base_url, token)

        if response_data and "result" in response_data and "sessions" in response_data["result"]:
            sessions = []
            for session_data in response_data["result"]["sessions"]:
                session_info = extract_session_info(base_url, session_data)
                sessions.append(session_info)
            
            return GetSessionsResponse(
                success=True,
                message=f"Found {len(sessions)} sessions",
                sessions=sessions
            )
        else:
            return GetSessionsResponse(
                success=False,
                message="No sessions found or unexpected response format",
                error=str(response_data) if response_data else "Empty response"
            )
            
    except HTTPException:
        raise
    except Exception as e:
        return GetSessionsResponse(
            success=False,
            message="Failed to get sessions",
            error=str(e)
        )

@app.post("/stop-session", response_model=StopSessionResponse)
async def stop_session_endpoint(
    request: StopSessionRequest,
    username: str = Header(..., description="User ID to look up token from tokens.json")
):
    """Stop/kill one or more sessions"""
    username, token = get_user_token(username)

    try:
        response_data = await stop_session_api(
            base_url=request.base_url,
            token=token,
            session_ids=request.session_ids,
            force_quit=request.force_quit,
            suspend_session=request.suspend_session
        )

        if response_data:
            return StopSessionResponse(
                success=True,
                message=f"Successfully stopped {len(request.session_ids)} sessions",
                stopped_sessions=request.session_ids
            )
        else:
            return StopSessionResponse(
                success=False,
                message="Empty response from external API",
                error="No response data received"
            )
            
    except HTTPException:
        raise
    except Exception as e:
        return StopSessionResponse(
            success=False,
            message="Failed to stop sessions",
            error=str(e)
        )

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
