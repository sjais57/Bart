from fastapi import FastAPI, HTTPException, Header
import subprocess
import json
import os
from typing import List, Dict, Any, Optional
from enum import Enum

app = FastAPI(title="Session Management API", version="1.0.0")

# Environment and Project enums
class Environment(str, Enum):
    DEV = "DEV"
    UAT = "UAT"
    PROD = "PROD"

class Project(str, Enum):
    PROJECT1 = "PROJECT1"
    PROJECT2 = "PROJECT2"

# Pydantic models for response
class UserAccessResponse(BaseModel):
    username: str
    user_groups: List[str]
    accessible_projects: Dict[str, List[str]]  # project -> list of environments
    has_access: bool

# Global variable for group config
GROUP_CONFIG = None
GROUP_CONFIG_FILE = "group_config.json"

def load_group_config() -> Dict[str, Any]:
    """Load group configuration from JSON file"""
    global GROUP_CONFIG
    
    try:
        script_dir = os.path.dirname(os.path.abspath(__file__))
        config_file_path = os.path.join(script_dir, GROUP_CONFIG_FILE)
        
        # Check if file exists
        if not os.path.exists(config_file_path):
            raise HTTPException(status_code=404, detail=f"Group config file '{GROUP_CONFIG_FILE}' not found")
        
        # Load data
        with open(config_file_path, 'r') as file:
            GROUP_CONFIG = json.load(file)
            
        return GROUP_CONFIG
            
    except json.JSONDecodeError as e:
        raise HTTPException(status_code=400, detail=f"Error parsing group config file: {e}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error loading group config: {e}")

def get_user_groups(username: str) -> List[str]:
    """Get user groups using the 'groups' command"""
    try:
        # Execute the groups command
        result = subprocess.run(
            ['groups', username],
            capture_output=True,
            text=True,
            check=True
        )
        
        # Parse the output - groups command returns: username : group1 group2 group3
        output = result.stdout.strip()
        if ':' in output:
            groups_part = output.split(':', 1)[1].strip()
            groups = groups_part.split()
            return groups
        else:
            return []
            
    except subprocess.CalledProcessError:
        # User might not exist or no groups
        return []
    except FileNotFoundError:
        raise HTTPException(status_code=500, detail="'groups' command not available on this system")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error getting user groups: {e}")

def check_project_access(user_groups: List[str], project_config: Dict[str, Any]) -> List[str]:
    """Check which environments user has access to for a given project"""
    accessible_environments = []
    
    for env, env_config in project_config.items():
        required_groups = env_config.get("groups", [])
        
        # Handle both string and list formats for groups
        if isinstance(required_groups, str):
            required_groups = [required_groups]
        
        # Check if user has any of the required groups
        if any(group in user_groups for group in required_groups):
            accessible_environments.append(env)
    
    return accessible_environments

@app.get("/user-project-access/{username}", response_model=UserAccessResponse)
async def get_user_project_access(username: str):
    """Get project access for a user based on group membership"""
    try:
        # Load group configuration
        group_config = load_group_config()
        
        # Get user's groups
        user_groups = get_user_groups(username)
        
        # Check access for each project
        accessible_projects = {}
        
        for project_name, project_config in group_config.get("project_name", {}).items():
            accessible_envs = check_project_access(user_groups, project_config)
            if accessible_envs:
                accessible_projects[project_name] = accessible_envs
        
        return UserAccessResponse(
            username=username,
            user_groups=user_groups,
            accessible_projects=accessible_projects,
            has_access=bool(accessible_projects)
        )
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error checking user access: {e}")

@app.get("/user-project-access", response_model=UserAccessResponse)
async def get_current_user_project_access(
    x_user_id: str = Header(..., description="Username to check access for")
):
    """Get project access for the current user (from header) based on group membership"""
    return await get_user_project_access(x_user_id)

# Load group config on startup
@app.on_event("startup")
async def startup_event():
    """Load group configuration when the application starts"""
    try:
        load_group_config()
        print("Group configuration loaded successfully")
    except Exception as e:
        print(f"Warning: Could not load group configuration: {e}")

