from fastapi import FastAPI, HTTPException, Header, Query
from pydantic import BaseModel, Field
import requests
import json
import os
import uvicorn
import re
import subprocess
from typing import List, Dict, Any, Optional
from enum import Enum
from datetime import datetime

app = FastAPI(title="Session Management API", version="1.0.0")

# Environment and Project enums
class Environment(str, Enum):
    DEV = "DEV"
    UAT = "UAT"
    PROD = "PROD"

class Project(str, Enum):
    PROJECT1 = "PROJECT1"
    PROJECT2 = "PROJECT2"

# Pydantic models for request/response
class LaunchSessionRequest(BaseModel):
    session_name: Optional[str] = Field(None, description="Optional custom session name. If not provided, will generate as 'JupyterLab Session {number}'")
    workbench: str = "JupyterLab"
    cluster: str = "Local"
    env: Environment = Field(..., description="Environment: DEV, UAT, or PROD")
    project: Project = Field(..., description="Project: PROJECT1 or PROJECT2")
    node_selection: Optional[str] = Field(None, description="Node selection for the session (optional for both projects)")

class StopSessionRequest(BaseModel):
    session_ids: List[str] = Field(..., description="List of session IDs to stop")
    force_quit: bool = False
    suspend_session: bool = False
    env: Environment = Field(..., description="Environment: DEV, UAT, or PROD")
    project: Project = Field(..., description="Project: PROJECT1 or PROJECT2")

class LaunchSessionResponse(BaseModel):
    success: bool
    message: str
    session_url: str = None
    session_name: str = None
    error: str = None

class SessionInfo(BaseModel):
    session_id: str
    url: str
    session_name: str
    display_name: str

class GetSessionsResponse(BaseModel):
    success: bool
    message: str
    sessions: List[SessionInfo] = []
    error: str = None

class StopSessionResponse(BaseModel):
    success: bool
    message: str
    stopped_sessions: List[str] = []
    error: str = None

class TokenResponse(BaseModel):
    username: str
    token: str = None
    available_users: List[str] = []

class AvailableUsersResponse(BaseModel):
    available_users: List[str]

class UserAccessResponse(BaseModel):
    username: str
    user_groups: List[str]
    accessible_projects: Dict[str, List[str]]  # project -> list of environments
    has_access: bool

class ReloadResponse(BaseModel):
    success: bool
    message: str
    timestamp: str

# API endpoints (relative paths)
LAUNCH_API = "/api/launch_session"
GET_SESSION_API = "/api/get_session"
STOP_SESSION_API = "/api/stop_session"

# Environment to base URL mapping
ENV_PROJECT_MAP = {
    Environment.DEV: {
        Project.PROJECT1: "dev-project1.example.com",
        Project.PROJECT2: "dev-project2.example.com"
    },
    Environment.UAT: {
        Project.PROJECT1: "uat-project1.example.com",
        Project.PROJECT2: "uat-project2.example.com"
    },
    Environment.PROD: {
        Project.PROJECT1: "prod-project1.example.com",
        Project.PROJECT2: "prod-project2.example.com"
    }
}

# Global variables to store data in memory
TOKENS_DATA = None
GROUP_CONFIG = None
TOKENS_FILE = "tokens.json"
GROUP_CONFIG_FILE = "group_config.json"
TOKENS_LAST_MODIFIED = None
GROUP_CONFIG_LAST_MODIFIED = None

def get_base_url(env: Environment, project: Project) -> str:
    """Get base URL based on environment and project"""
    base_url = ENV_PROJECT_MAP.get(env, {}).get(project)
    if not base_url:
        raise HTTPException(
            status_code=400,
            detail=f"No base URL configured for environment '{env}' and project '{project}'"
        )
    return base_url

def format_base_url(base_url: str) -> str:
    """Format base URL to ensure it has https:// prefix"""
    if not base_url.startswith(('http://', 'https://')):
        return f"https://{base_url}"
    return base_url

# Token management functions
def load_tokens_data(force_reload: bool = False) -> Dict[str, Any]:
    """Load tokens data from JSON file into memory"""
    global TOKENS_DATA, TOKENS_LAST_MODIFIED
    
    try:
        script_dir = os.path.dirname(os.path.abspath(__file__))
        token_file_path = os.path.join(script_dir, TOKENS_FILE)
        
        # Check if file exists
        if not os.path.exists(token_file_path):
            raise FileNotFoundError(f"Token file '{TOKENS_FILE}' not found")
        
        # Check if file has been modified
        current_mtime = os.path.getmtime(token_file_path)
        
        # Load data if not already loaded, force reload, or file has been modified
        if TOKENS_DATA is None or force_reload or (TOKENS_LAST_MODIFIED and current_mtime > TOKENS_LAST_MODIFIED):
            with open(token_file_path, 'r') as file:
                TOKENS_DATA = json.load(file)
            TOKENS_LAST_MODIFIED = current_mtime
            print(f"Tokens data reloaded at {datetime.now()}")
            
        return TOKENS_DATA
            
    except json.JSONDecodeError as e:
        raise HTTPException(status_code=400, detail=f"Error parsing JSON file '{TOKENS_FILE}': {e}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error loading token file: {e}")

def get_token_from_memory(project_name: str, env: Environment, username: str) -> str:
    """Get token from in-memory data based on project, environment, and username"""
    tokens_data = load_tokens_data()
    
    # Navigate through the nested structure: project_name -> env -> username
    project_data = tokens_data.get(project_name)
    if not project_data:
        raise HTTPException(status_code=404, detail=f"Project '{project_name}' not found in token file")
    
    env_data = project_data.get(env.value)
    if not env_data:
        raise HTTPException(status_code=404, detail=f"Environment '{env}' not found for project '{project_name}'")
    
    token = env_data.get(username)
    if not token:
        raise HTTPException(status_code=404, detail=f"Token not found for user '{username}' in project '{project_name}', environment '{env}'")
    
    return token

def get_available_users_from_memory(project: Optional[Project] = None, env: Optional[Environment] = None) -> List[str]:
    """Get list of available users from in-memory tokens data with optional filtering"""
    try:
        tokens_data = load_tokens_data()
        
        users = set()
        
        # Filter by project if specified
        projects_to_check = [project.value] if project else tokens_data.keys()
        
        for project_name in projects_to_check:
            project_data = tokens_data.get(project_name, {})
            
            # Filter by environment if specified
            envs_to_check = [env.value] if env else project_data.keys()
            
            for env_name in envs_to_check:
                env_data = project_data.get(env_name, {})
                users.update(env_data.keys())
        
        return sorted(list(users))
        
    except Exception:
        return []

def get_user_token(project: Project, env: Environment, username: str) -> tuple[str, str]:
    """Centralized function to get user ID and token"""
    token = get_token_from_memory(project.value, env, username)
    return username, token

# Group configuration functions
def load_group_config(force_reload: bool = False) -> Dict[str, Any]:
    """Load group configuration from JSON file"""
    global GROUP_CONFIG, GROUP_CONFIG_LAST_MODIFIED
    
    try:
        script_dir = os.path.dirname(os.path.abspath(__file__))
        config_file_path = os.path.join(script_dir, GROUP_CONFIG_FILE)
        
        # Check if file exists
        if not os.path.exists(config_file_path):
            raise HTTPException(status_code=404, detail=f"Group config file '{GROUP_CONFIG_FILE}' not found")
        
        # Check if file has been modified
        current_mtime = os.path.getmtime(config_file_path)
        
        # Load data if not already loaded, force reload, or file has been modified
        if GROUP_CONFIG is None or force_reload or (GROUP_CONFIG_LAST_MODIFIED and current_mtime > GROUP_CONFIG_LAST_MODIFIED):
            with open(config_file_path, 'r') as file:
                GROUP_CONFIG = json.load(file)
            GROUP_CONFIG_LAST_MODIFIED = current_mtime
            print(f"Group configuration reloaded at {datetime.now()}")
            
        return GROUP_CONFIG
            
    except json.JSONDecodeError as e:
        raise HTTPException(status_code=400, detail=f"Error parsing group config file: {e}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error loading group config: {e}")

def get_user_groups(username: str) -> List[str]:
    """Get user groups using the 'groups' command"""
    try:
        # Execute the groups command
        result = subprocess.run(
            ['groups', username],
            capture_output=True,
            text=True,
            check=True
        )
        
        # Parse the output - groups command returns: username : group1 group2 group3
        output = result.stdout.strip()
        if ':' in output:
            groups_part = output.split(':', 1)[1].strip()
            groups = groups_part.split()
            return groups
        else:
            return []
            
    except subprocess.CalledProcessError:
        # User might not exist or no groups
        return []
    except FileNotFoundError:
        raise HTTPException(status_code=500, detail="'groups' command not available on this system")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error getting user groups: {e}")

def check_project_access(user_groups: List[str], project_config: Dict[str, Any]) -> List[str]:
    """Check which environments user has access to for a given project"""
    accessible_environments = []
    
    for env, env_config in project_config.items():
        required_groups = env_config.get("groups", [])
        
        # Handle both string and list formats for groups
        if isinstance(required_groups, str):
            required_groups = [required_groups]
        
        # Check if user has any of the required groups
        if any(group in user_groups for group in required_groups):
            accessible_environments.append(env)
    
    return accessible_environments

# ... (rest of the existing functions remain the same: make_api_request, validate_node_selection, get_sessions_api, stop_session_api, extract_session_info, get_next_available_session_number, launch_session_api) ...

# Load data into memory on startup
@app.on_event("startup")
async def startup_event():
    """Load tokens and group configuration data into memory when the application starts"""
    try:
        load_tokens_data()
        print("Tokens data loaded successfully into memory")
    except Exception as e:
        print(f"Warning: Could not load tokens data on startup: {e}")
    
    try:
        load_group_config()
        print("Group configuration loaded successfully into memory")
    except Exception as e:
        print(f"Warning: Could not load group configuration: {e}")

# Endpoints
@app.get("/")
async def root():
    """Root endpoint with API information"""
    return {
        "message": "Session Management API",
        "version": "1.0.0",
        "endpoints": {
            "GET /tokens/{project}/{env}/{username}": "Get token for a specific user in project and environment",
            "POST /launch-session": "Launch a new session (requires X-User-ID header, env, project in body; node_selection optional)",
            "GET /sessions": "Get all sessions for a user (requires X-User-ID header, env and project in query params)",
            "POST /stop-session": "Stop/kill one or more sessions (requires X-User-ID header, env and project in body)",
            "GET /available-users": "Get list of available users",
            "GET /available-users/{project}/{env}": "Get list of available users for specific project and environment",
            "GET /env-projects": "Get available environment and project combinations",
            "GET /user-project-access/{username}": "Get project access for a user based on group membership",
            "GET /user-project-access": "Get project access for current user (from X-User-ID header)",
            "POST /admin/reload-tokens": "Reload tokens.json file",
            "POST /admin/reload-group-config": "Reload group_config.json file"
        }
    }

@app.get("/env-projects")
async def get_env_projects():
    """Get available environment and project combinations"""
    return {
        "environments": [env.value for env in Environment],
        "projects": [project.value for project in Project],
        "mappings": ENV_PROJECT_MAP
    }

@app.get("/tokens/{project}/{env}/{username}", response_model=TokenResponse)
async def get_token(project: Project, env: Environment, username: str):
    """Get token for a specific user in a specific project and environment"""
    token = get_token_from_memory(project.value, env, username)
    available_users = get_available_users_from_memory(project, env)
    
    return TokenResponse(
        username=username,
        token=token,
        available_users=available_users
    )

@app.get("/available-users", response_model=AvailableUsersResponse)
async def get_available_users_endpoint():
    """Get list of all available users from tokens file"""
    users = get_available_users_from_memory()
    return AvailableUsersResponse(available_users=users)

@app.get("/available-users/{project}", response_model=AvailableUsersResponse)
async def get_available_users_by_project(project: Project):
    """Get list of available users for a specific project"""
    users = get_available_users_from_memory(project=project)
    return AvailableUsersResponse(available_users=users)

@app.get("/available-users/{project}/{env}", response_model=AvailableUsersResponse)
async def get_available_users_by_project_env(project: Project, env: Environment):
    """Get list of available users for a specific project and environment"""
    users = get_available_users_from_memory(project=project, env=env)
    return AvailableUsersResponse(available_users=users)

@app.get("/user-project-access/{username}", response_model=UserAccessResponse)
async def get_user_project_access(username: str):
    """Get project access for a user based on group membership"""
    try:
        # Load group configuration
        group_config = load_group_config()
        
        # Get user's groups
        user_groups = get_user_groups(username)
        
        # Check access for each project
        accessible_projects = {}
        
        project_configs = group_config.get("project_name", {})
        for project_name, project_config in project_configs.items():
            accessible_envs = check_project_access(user_groups, project_config)
            if accessible_envs:
                accessible_projects[project_name] = accessible_envs
        
        return UserAccessResponse(
            username=username,
            user_groups=user_groups,
            accessible_projects=accessible_projects,
            has_access=bool(accessible_projects)
        )
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error checking user access: {e}")

@app.get("/user-project-access", response_model=UserAccessResponse)
async def get_current_user_project_access(
    x_user_id: str = Header(..., description="Username to check access for")
):
    """Get project access for the current user (from header) based on group membership"""
    return await get_user_project_access(x_user_id)

@app.post("/admin/reload-tokens", response_model=ReloadResponse)
async def reload_tokens():
    """Reload tokens.json file"""
    try:
        load_tokens_data(force_reload=True)
        return ReloadResponse(
            success=True,
            message="Tokens data reloaded successfully",
            timestamp=datetime.now().isoformat()
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to reload tokens: {e}")

@app.post("/admin/reload-group-config", response_model=ReloadResponse)
async def reload_group_config():
    """Reload group_config.json file"""
    try:
        load_group_config(force_reload=True)
        return ReloadResponse(
            success=True,
            message="Group configuration reloaded successfully",
            timestamp=datetime.now().isoformat()
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to reload group config: {e}")

# ... (rest of the existing endpoints remain the same: launch-session, sessions, stop-session) ...

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
